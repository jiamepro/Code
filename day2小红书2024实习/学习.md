经验学习：[使用C++刷算法题的简明教程](https://blog.csdn.net/m0_50226268/article/details/122674322)

string类，定义、拼接、输出、处理都更加简单：拼接 +

⽤cin读⼊字符串的时候，是以空格为分隔符的，如果想要读⼊⼀整⾏的字符串，就需要⽤getline，s的长度可以⽤s.length()获取（有几个字符就是⻓度多少，不存在char[]里面的什么末尾的结束符之类的）

string中还有个很常⽤的函数叫做substr，作⽤是截取某个字符串中的⼦串

C++里面的引⽤是指在变量名之前加⼀个&符号，原理？？？跟指针的区别？？

C++⾥⾯有⼀个能完全替代数组的动态数组vector

学习各个模板的用法，官方网站最详细：[C++官方网站](https://cplusplus.com/)

使用迭代器遍历：for (auto it = c.begin(); it != c.end(); it++) cout << *it << " ";

bitset⽤来处理⼆进制位非常⽅便。头文件是 #include<bitset> 

sort函数在头文件 #include<algorithm> ⾥⾯，主要是对数组进行排序

自己定义⼀个cmp函数指定排序规则，就可以写⼀个cmp数组实现这个看上去有点复杂的排序过程

在cctype中已经定义好了判断这些字符应该所属的范围，直接引⼊这个头文件并且使用里面的函数判断即可，无需自己手写：if (isalpha(c))

在STL中使⽤迭代器的时候，auto可以代替一大长串的迭代器类型声明：

to_string的头文件是 #include <string> ，to_string最常用的就是把⼀个int型变量或者⼀个数字转化为string类型的变量

[C++教程](https://blog.csdn.net/weixin_44368437/article/details/117563488)

C++提供了一种更灵活、更安全的方式来定义常量，即使用const修饰符来定义常量

变量的引用就是变量的别名，因此引用又称别名。int &j = i; i和j的值相同，地址也相同，引用与其所代表的变量共享同一内存单元，系统并不为引用另外分配存储空间。
//拷贝构造函数，自引用指针，静态成员变量/函数,友元，集成，派生类构造函数，多态，函数重载，虚函数，虚基类，抽象类
通常默认的拷贝构造函数是能够胜任此工作的，但若类中含有指针类型的数据，则这种按数据成员逐一赋值的方法会产生错误。

this指针保存当前对象的地址，称为自引用指针。

使用对象引用作为函数参数：在实际中，使用对象引用作为函数参数非常普遍，大部分程序员喜欢使用对象引用替代对象指针作为函数参数。因为使用对象引用作为函数参数不但具有用对象指针做函数参数的优点，而且用对象引用作函数参数将更简单、更直接。

与一般的数据成员不同，无论建立多少个类的对象，都只有一个静态数据成员的拷贝。从而实现了同一个类的不同对象之间的数据共享。

静态成员函数的作用不是为了对象之间的沟通，而是为了处理静态数据成员。

友元函数既可以是不属于任何类的非成员函数，也可以是另一个类的成员函数。友元函数不是当前类的成员函数，但它可以访问该类的所有成员，包括私有成员、保护成员和公有成员。

在类中声明友元函数时，需要在其函数名前加上关键字friend。多个类的友元函数能够访问相关的所有类的数据

当一个类被说明为另一个类的友元类时，它所有的成员函数都成为另一个类的友元函数，这就意味着作为友元类中的所有成员函数都可以访问另一个类中的所有成员。

在一个类中内嵌另一个类的对象作为数据成员，称为类的组合。该内嵌对象称为对象成员，又称为子对象。

若基类使用默认构造函数或不带参数的构造函数，则在派生类中定义构造函数时可略去“:基类构造函数名(参数表)”，此时若派生类也不需要构造函数，则可不定义构造函数。

虚基类？？不难理解，如果在上列中类base只存在一个拷贝(即只有一个数据成员a)，那么对a的访问就不会产生二义性。在C++中，可以通过将这个公共的基类声明为虚基类来解决这个问题。

C++实际上采用了静态连编和动态连编相结合的方式。

在C++中，编译时多态性主要是通过函数重载和运算符重载实现的；运行时多态性主要是通过虚函数来实现的。

在基类中的某个成员函数被声明为虚函数后，此虚函数就可以在一个或多个派生类中被重新定义。

虽然使用对象名和点运算符的方式也可以调用虚函数，如mom.like()可以调用虚函数Mother::like()。但是，这种调用是在编译时进行的静态连编，它没有充分利用虚函数的特性，只有通过基类指针访问虚函数时才能获得运行时的多态性

但是如果将基类的析构函数定义为虚函数，由该类所派生的所有派生类的析构函数也都自动成为虚函数。

由于抽象类中至少包含一个没有定义功能的纯虚函数。因此，抽象类只能作为其他类的基类来使用，不能建立抽象类对象。

模板解决：在程序设计中往往存在这样的现象：两个或多个函数的函数体完全相同，差别仅在与它们的参数类型不同。代替C语言的宏定义函数

所谓函数模板，实际上是建立一个通用函数，其函数返回类型和形参类型不具体指定，用一个虚拟的类型来代表，这个通用函数就称为函数模板。

标准模版库就是用模版的语法写的

凡是数据从一个地方传输到另一个地方的操作都是流的操作

九、C++的输入和输出

异常处理：
C++处理异常的办法：如果在执行一个函数的过程中出现异常，可以不在本函数中立即处理，而是发出一个信息，传给它的上一级（即调用函数）来解决，如果上一级函数也不能处理，就再传给其上一级，由其上一级处理。如此逐级上传，如果到最高一级还无法处理，运行系统一般会自动调用系统函数terminate()，由它调用abort终止程序。

try catch