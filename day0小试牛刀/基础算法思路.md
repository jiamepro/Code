# 
[TOC]
在这里打基础，每天练手，线上刷题用C++，基础算法用C写
## 排序
时间复杂度、空间复杂度、算法稳定性
* 先写和总结，复习的时候把这些算法再自己重新写一遍，基础算法不能手生！！！！
* 代码都在~/Code/*里
* 写代码之前可以画流程框图，梳理思路
* 就像之前凯哥刷题那样！简单题、典型题打基础，难题其实就是简单题的组合和抽象！
### 冒泡排序/简单选择排序
* 遍历数组，遍历后边n - i个数，把较小的换到i的位置，最终i位置是该范围内最小的
* 优化: 先不交换，记录较小值的下标，遍历完后边所有数之后，再交换(交换次数少)

### 插入排序
#### 二分法插入排序
[二分排序](https://blog.csdn.net/qq1641530151/article/details/80631201)
* 应用场景：在一个有序数列中插入一个新数
* 细节在于：结束条件和游标改变条件！
  * 假如待加入的数不在数组[left,right]以内，假如 [left, right] < a, 那么循环应该left一直加，加到left == right跳出
    * 所以游标改变条件为：mid = left + (right - left + 1)/2;left和right相邻时mid = left + 1; 如果 a > mid, left = mid;
    * 但是数a不在数组[left,right]以内，还有可能a < [left, right], 那么相邻时right = right... 所以死循环了...
    * 而且不管怎么改游标条件，两种可能发生的时候，其中之一都会发生死循环
  * 所以要单独处理待加入的数不在数组[left,right]以内情况？不不不搞复杂了！只需要将游标该表条件改为mid + 1 和 mid - 1就行了，就不会发生left或者right不变的情况了
  * 现在如果待加入的数不在数组[left,right]以内，
    * 假如 [left, right] < a，游标改变条件为：mid = left + (right - left)/2; left和right相邻时mid = left; 所以 a > mid, left = mid + 1;
    * 还有可能a < [left, right]，mid = left + (right - left)/2，left和right相邻时mid = left; 所以 a < mid, right = mid = left; 
    * 但是如果得出结果，要插入a的时候，无论同一插到后面还是插到前面都有一个元素要出问题？？有什么统一的插入法？
      * 把其中之一的端点拿出来单独处理：假如统一后插，就把前插到端点的情况单独处理
      * nonono，写代码的时候发现，我找到left=right这个点，这个点是最接近a的，直接判断与这个点的相对位置决定前插还是后插就行了啊
  * 细节：数跟数比较，下标跟下标比较，注意看比较的东西是不是同一性质
  * 出问题: 端点值被覆盖？细节，执行数组下标出现[i - 1]或者[i + 1]时，要检查循环条件，可能多涉及了一个位置
  * 细节：移动数组，要从后边往前移动，保证赋值的数字是有效的，注意i是递减
* 具体代码
```c
//数组大小远远大于输入数字的数量，n来计数
int n = 0, a[34] = {0}, b;
//二分插入排序
    while( scanf("%d", &a[n]) != EOF){//大有讲究
        //最后一个数字输入的时候需要多打一个空格！怎么解决？
        //输入方式的问题 修改while( (scanf("%d", &a[n])) && getchar() != '\n')
        n++;//注意位置
        int left = 0, right = n - 2;//每次插入一个新数时，新数为a[n-1]，
        while(left < right) // n = 1 ,2时都不执行
        {
            int mid = left + (right - left)/2; //right与left相邻时 mid = left，在a > a[mid]时可能导致死循环
            if(a[n - 1] < a[mid])  right = mid;
            else left = mid + 1; //相邻时，插入数大于a[mid]，left = mid可能导致left死循环,所以left = mid + 1
        }//退出时left == right
        
        a[n] = a[n - 1];// a[n]作为临时数组存储待插入数字
        if(a[n] < a[left]) 
        //最后退出的时候，这个待插入数可能大于left/right也可能小于left/right，可以确定的是只可能在附近，不可能跨数，因为二分法锁定了区间了，区间 = 1之后退出了
        //而在前或者在后决定，这个数是前插还是后插，所以加一个判断！
        {
            for(int i = n - 1; i > left; i--) a[i] = a[i - 1];
            a[left] = a[n];
        }
        else if(a[n] > a[left])
        {
            for(int i = n - 1; i > left + 1; i--) a[i] = a[i - 1];
            a[left + 1] = a[n];
        }
        else ; //n = 1时，两个相等数，也不执行
        if(getchar() == '\n') break;//这种方式就要求，最后输入决定不能打空格！
    };
```
* 注意：用移位代替除法 >> 1 就代表除2
* 注意：移位的优先级小于算数运算！想要先移位要加括号！
* 检验：机考时候少用不熟悉的操作，平时可以多尝试
* AVL路径就是二叉平衡树路径，二叉平衡树的搜索就是二分法，根本不用树的数据结构，想太多了，把自己整笑了...

#### 直接插入排序+希尔排序
* [直接插入排序算法](https://blog.csdn.net/qq_44616044/article/details/115708056)
* 思路：将数组分为以排序和未排序，每次取出未排序的第一个元素，从后向前判断该插入到哪个位置，暂存待插，其他往后以移位
* 又可以：取完再插，边取边插，时间复杂度是一样的，但显然取完再插思路更清晰
* 注意：数组移动从前往后会覆盖
* 优化！！！！整体部分思想，先让部分有序，让整体基本有序，再插入
--
* 希尔排序第一次把排序算法的复杂度降下来了 [希尔排序](https://blog.csdn.net/weixin_52811588/article/details/126454328)
* 希尔排序，算法不稳定是什么意思？随希尔增量选择，代码效果不同
* 希尔排序在越大的数组上更能发挥优势
### 堆排序

### 快速排序

### 并归排序


...桶排序，外部排序
## 查找
### 链表

### 二叉树

### 图