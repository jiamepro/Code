[HOT100](https://leetcode.cn/studyplan/top-100-liked/)
[面试经典150](https://leetcode.cn/studyplan/top-interview-150/)
### day12：2024年06月17日
困难题: K个一组翻转链表(看题解)
- 链表后方元素如何指向链表前方元素（反转链表）
  - 从前方遍历，依次修改指向方向
- 困难题都看答案敲

中等题：随机链表的复制(看题解)
- Random指针如何copy？
  - 哈希表 + 
### day13：2024年6月18日
中等题：排序链表(看题解)
- 做错...
- 并归...细节太多
  - 找中点:快慢指针
  - 合并两个有序链表

### day14: 2024年06月20日
困难题：合并K个升序链表(看题解)
- 三种解法(直接，**优先级队列**，分组)
- [大顶堆的定义](https://blog.csdn.net/yao_hou/article/details/127810575)
- [优先级队列的定义](https://blog.csdn.net/weixin_49403089/article/details/135923128)
- [优先级队列定义2](https://blog.csdn.net/qq_55712347/article/details/128874870)

中等题：LRU缓存(看题解)
- 哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表
- LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。
- 使用双向链表：删除一个节点不光要得到该节点本身的指针，也需要操作其前驱节点的指针，而双向链表才能支持直接查找前驱
- 在这两种数据结构之上提供一层抽象 API，减少操作细节
- 3、map提供了两种方式，查看是否包含key，m.count(key)，m.find(key)。

4、m.count(key)：由于map不包含重复的key，因此m.count(key)取值为0，或者1，表示是否包含。

5、m.find(key)：返回迭代器，判断是否存在。

C++写法：list

- 太难的题背答案...

简单题：二叉树中序遍历
- 